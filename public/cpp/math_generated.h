// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MATH_TECHPAWS_SCHEMES_MATH_H_
#define FLATBUFFERS_GENERATED_MATH_TECHPAWS_SCHEMES_MATH_H_

#include "flatbuffers/flatbuffers.h"

namespace TechPaws {
namespace Schemes {
namespace Math {

struct Vec2f;

struct Vec3f;

struct Vec4f;

struct Mat4f;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec2f FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2f() {
    memset(static_cast<void *>(this), 0, sizeof(Vec2f));
  }
  Vec2f(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vec2f, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3f FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3f() {
    memset(static_cast<void *>(this), 0, sizeof(Vec3f));
  }
  Vec3f(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vec3f, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec4f FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Vec4f() {
    memset(static_cast<void *>(this), 0, sizeof(Vec4f));
  }
  Vec4f(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(Vec4f, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Mat4f FLATBUFFERS_FINAL_CLASS {
 private:
  TechPaws::Schemes::Math::Vec4f c1_;
  TechPaws::Schemes::Math::Vec4f c2_;
  TechPaws::Schemes::Math::Vec4f c3_;
  TechPaws::Schemes::Math::Vec4f c4_;

 public:
  Mat4f() {
    memset(static_cast<void *>(this), 0, sizeof(Mat4f));
  }
  Mat4f(const TechPaws::Schemes::Math::Vec4f &_c1, const TechPaws::Schemes::Math::Vec4f &_c2, const TechPaws::Schemes::Math::Vec4f &_c3, const TechPaws::Schemes::Math::Vec4f &_c4)
      : c1_(_c1),
        c2_(_c2),
        c3_(_c3),
        c4_(_c4) {
  }
  const TechPaws::Schemes::Math::Vec4f &c1() const {
    return c1_;
  }
  const TechPaws::Schemes::Math::Vec4f &c2() const {
    return c2_;
  }
  const TechPaws::Schemes::Math::Vec4f &c3() const {
    return c3_;
  }
  const TechPaws::Schemes::Math::Vec4f &c4() const {
    return c4_;
  }
};
FLATBUFFERS_STRUCT_END(Mat4f, 64);

}  // namespace Math
}  // namespace Schemes
}  // namespace TechPaws

#endif  // FLATBUFFERS_GENERATED_MATH_TECHPAWS_SCHEMES_MATH_H_
